Online Multiplayer Tic-Tac-Toe

The purpose of this project was to allow multiple concurrent users to connect through the localhost and play games against each other. Once a user has connected, they will be added to the next free game, and a new game can take place.
The project was written using HTML, CSS + bootstrap, JavaScript + jQuery + Node.js & Express.js, as well as Socket.io. Aside from the compulsory Node, Express and Socket.io dependencies, jQuery was used to aid in DOM manipulation simplicity, and bootstrap was used mainly for ease in setting up the tic-tac-toe grid, and other useful features like text aligning. 
A basic client-server model is used to allow the clients, which are each open window of the application on localhost:8080, to communicate with the server. The server manages all the users and currently running games, with all communication following a flow of either being from the client to the server, server to the client, or client to the server and followed through to another client. This design allowed the use of features offered by Socket.io to pass information between two players within a single game of tic-tac-toe.

![alt text](https://i.imgur.com/Yub7KlG.png)
An example of the gameplay handling is shown in the figure above. There can be many games running between sets of two users, but the communication flow is only between a client and server at any given time.
The server first waits for a client to connect, then it stores the client information in a structure that contains information about each of the games running. This is the way clients are matched up together into a single game with two players. Once the information is stored, the connected client is sent information about the game they are participating in, and whether they can make a move. To keep the turns flowing correctly, the first connected player is assigned to the piece ‘X’ and is required to go first. They must wait for a second player to connect, then the game can start. After the player makes a move, the cell number is sent to the server, which then notifies the other player of the game to update their board and allowing them to perform their turn.
An emphasis has been placed on minimising the amount of information that needs to be sent back and forth between the clients in a game and the server, and as such information is only sent to the server once the other player needs to be notified about a state change. Each of the clients manage their own turns and updating of their boards after performing their turn, but once they have completed their turn the server will be notified of board changes, whether win conditions are met, game resets and disconnections. This information is then sent to the other player if required.
The clients can execute commands on their version of the game board by listening to specific messages from the server. Examples of commands include: ‘pieceRegistration’, ‘notifyTurn’, ‘updateBoard’, ‘endGame’ and ‘reset’. Each command gives the client necessary information to continue the game flow correctly. It keeps the flow simple, easy to read and understand. Each client only needs to receive information pertaining to when it is their move, what piece they can place, and what piece the opponent has just placed. This allows the client to track the game’s progress while being able to make valid moves. It gives the clients an ability to affect the game they are currently in, without affecting any other games, or the abilities of their opponent. This is where the server comes in, giving clients their own roles and abilities, as well as the concurrent multi-game bonus feature.
Minimal setup is required to run the application, and the only prerequisites are having Node.js and Express.js installed. Once these dependencies are installed, to run the application:
-	Navigate to the base directory in the command line
-	Run the command: npm install
-	Run the command: node app.js
-	Open as many browser windows as desired, for each of which you should navigate to the address: http://localhost:8080
Features that should be noted include having invalid inputs handled through a message box underneath the game board. This involves notifying the user that they are unable to make a move when it isn’t their turn, as well as when invalid squares have been chosen. The area above the game board shows information about what game the player is currently in, what piece they have been assigned to, a message indicating which player’s turn it is, and a reset button.
An additional feature outside of the assignment scope is allowing multiple concurrent games to run. As mentioned previously, when clients connect to the server, the server determines which game is free, or in the event there isn’t any free games, adds the user to a new empty game.
The application was designed in a way to make the client/server functionality separate and easily extendable. As various events are emitted which provide distinct functionality, additional features could be simply added distinctly from the existing functionality, allowing use of the existing event functions as needed.
